---
layout: post
title: "NPM Package Development Tips"
description: "Creating high quality NPM packages to share with the community is not hard. It's all about configuring the right tools to helps us keeping code quality high. Let's check what these tools are and how to configure them through a practical exercise."
date: "2017-12-13 08:30"
author:
  name: "Bruno Krebs"
  url: "brunoskrebs"
  mail: "bruno.krebs@gmail.com"
  avatar: "https://twitter.com/brunoskrebs/profile_image?size=original"
related:
- 2017-11-15-an-example-of-all-possible-elements
---

**TL;DR:**

## What NPM Package Will We Build

## Git and GitHub

- ask to install git

### Creating the GitHub Repository

Great, we already decided where we will keep our source code safe. It's time to create the repository to start working on it. If we head to [the _Create a new repository_ web page on GitHub](https://github.com/new), we will see a form that asks for three things: repository name, description, and visibility. As we are building a module that handles masks, let's answer these questions as follows:

- **Repository name**: masks-js
- **Description**: A NPM package that exports functions to mask values.
- **Visibility**: Public

After that, GitHub gives us options to initialize the repository with a `README` file, to add a `.gitignore` file, and to add a license to our module. We will use all three options as follows:

- **Create README**: Yes, let's check this box.
- **Add .gitignore**: Why not? Less typing later. Let's choose `Node` in this combo.
- **Add a license**: Again, less work later. Let's set this combo to `MIT License`.

Done! We can hit the _Create repository_ button to finish the process.

### Cloning the GitHub Repository

After creating the repository (which should be instantaneous), GitHub will redirect us to the our repository's webpage. There, we can find a button called _Clone or download_ that gives a shortcut to the URL that we will need. Let's copy this URL and open a terminal. On this terminal, let's choose an appropriate directory to host the root directory of our project (e.g. `~/git`), and then let's clone the repository.

The code snippet below shows the commands that have to be used to clone the repository:

```bash
# choosing a directory to clone our repo
cd ~/git

# using git to clone
git clone git@github.com:brunokrebs/masks-js.git

# moving cursor to project root
cd masks-js
```

The last command will put our terminal in the project root. There, if we list the existing content, we will see four items:

- A directory called `.git` that is used by Git to control the version of our code locally. Most probably, we will never touch this directory and its content manually.
- A file called `.gitignore` where we keep entries that identify items that we do not want Git to version. For example, in the near future, we will add a `node_modules/` line to this file to make Git ignore modules installed locally.
- A file called `LICENSE`. We don't have to touch this file, it contains a predefined content granting the [MIT License](https://opensource.org/licenses/MIT) to our code/package.
- A file called `README.md` that contains, for now, just the name of our package (`masks-js`) and its description. We will edit this file later to include instructions on how to use our package and other handy information.

### Ignoring Files with Git

## IDEs (Integrated Development Environments)

Developing good software, arguably, passes through a good IDE. Among other things, IDEs can help us refactor our code, be more productive (mainly if we know their shortcuts), and debug our code. They usually help us by pointing out possible problems before compiling and/or running our code either. Therefore, this is a topic that cannot be put aside.

On the Node.js/NPM environment, there is a good number of IDEs available. A few of them are paid and lot are free. However, in the author's opinion, there are only two IDEs that are really relevant: WebStorm and Visual Studio Code.

[_WebStorm_](https://www.jetbrains.com/webstorm/): This is a full-fledged IDE that provides great tools and has great support to everything related to JavaScript (e.g. TypeScript, HTML, CSS, SCSS, Angular, Git, etc). If it does not support some feature by default, it probably does so through [plugins](https://plugins.jetbrains.com/webstorm). The biggest disadvantage of this IDE is that [it's paid](https://www.jetbrains.com/webstorm/buy/#edition=personal). However, WebStorm is so good at what it does that it worths its price.

[_Visual Studio Code_](https://code.visualstudio.com/): This is another full-fledged IDE. It also comes with great support for Node.js and related technologies, just like WebStorm does. This IDE, in contrast to WebStorm, is free and open source. If you are wondering the difference between them, there are a few resources out there that compare both. For example, there is [this article on Medium](https://medium.com/linagora-engineering/from-webstorm-to-vscode-road-to-the-freedom-743eda17164a) and [this discussing on Reddit](https://www.reddit.com/r/webdev/comments/5fcldt/webstorm_vs_visual_studio_code/).

Other options, although famous, cannot be really considered IDEs. That is, they can be considered IDEs if they are correctly configured with a bunch of plugins. However, why waste time on these kind of configuration when we can choose a good IDE that is ready to help us? If you are still interested on seeing what other "IDEs" are available, [there are resources out there show more options and their differences](https://www.google.com.br/search?q=node.js+ides).

What is important in this section is that we understand that we _do_ need an IDE and choose one. This will help us a lot during the lifecycle of our package.

## NPM Package Development

Now that we have chosen our IDE, let's open our project and start configuring it. Throughout the next sections, we are going to create our project structure and configure tools that will help us produce high-quality code.

### NPM Init

First things first. As our goal is to create and publish a NPM package, we need to initialize our project as one. Luckily, the process is straightforward. NPM, through its CLI (Command Line Interface tool), provides two great ways to configure a project as a NPM package. The first one, triggered by `npm init`, will ask a bunch of questions and produce the `package.json` file for us. The second one, triggered by `npm init -y`, will not ask any question and produce the `package.json` file with default values.

We will stick with the second option, `npm init -y`, to get our file as fast as possible. Then, we will edit the `package.json` content manually to look like this:

```json
{
  "name": "masks-js",
  "version": "0.0.1",
  "description": "A NPM package that exports functions to mask values.",
  "main": "build/index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/brunokrebs/masks-js.git"
  },
  "keywords": [
    "npm",
    "node",
    "masks",
    "javascript"
  ],
  "author": "Bruno Krebs",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/brunokrebs/masks-js/issues"
  },
  "homepage": "https://github.com/brunokrebs/masks-js#readme"
}
```

Two properties in the file above may bring our attention. The `main` property now points to `build/index.js` and the `version` property labels our code as being on version `0.0.1`. Let's not worry about them now, we will discuss about these properties in the following sections.

### Semantic Versioning

In this section, we are not going to change anything in our project. The focus here is to talk about how to label new releases of our package. In the NPM and Node.js landscape, the most used strategy is by far [Semantic Versioning](https://semver.org/). What makes this strategy so special is that it has a well-defined schema that makes it easy to identify what versions are interoperable.

Semantic Version, also known as SemVer, uses the following schema: `MAJOR.MINOR.PATCH`. As we can see, any version is divided into three parts:

- `MAJOR`: A number that we increment when we make incompatible API changes.
- `MINOR`: A number that we increment when we add features in a backwards-compatible manner.
- `PATCH`: A number that we increment when we make small bug fixes.

That is, if we have a problem with our code and fix it simply by changing an `if` statement, we have to increment the `PATCH` part: `1.0.0` => `1.0.1`. However, if we need to add a new function (without changing anything else) to handle this new scenario, then we increment the `MINOR` part: `1.0.0` => `1.1.0`. Lastly, if this bug is so big that requires a whole lot of refactoring and API changes, then we increment the `MAJOR` part: `1.0.0` => `2.0.0`.

### EditorConfig

[EditorConfig](http://editorconfig.org/) is a small configuration file that we put in the project root to define how IDEs and text editors must format our files. Many IDEs support EditorConfig out of the box (including WebStorm and Visual Studio Code). The ones that don't, usually have a plugin that can be installed.

At the time of writing, EditorConfig contains only a small (but useful) set of properties. We will use most of them, but two are worth mentioning:

- `indent_style`: Through this property, we define if we want our code to be indented with tabs or spaces.
- `charset`: We use this property to state what charset (e.g. UTF-8) we want our files encoded into.

To set up EditorConfig in our project, we need to create a file called `.editorconfig` in the project root. On it, we define how we want IDEs to handle our files:

```bash
# Editor configuration, see http://editorconfig.org
root = true

[*]
charset = utf-8
indent_style = space
indent_size = 2
insert_final_newline = true
trim_trailing_whitespace = true
```

__Note__: EditorConfig can handle multiple configuration blocks. In the example above, we added a single block defining that all files (`[*]`) must be encoded in `UTF-8`, indented with `spaces`, and so on. However, we could have defined that we wanted XML files (`[*.xml]`) to be indented with tabs, for example.

Although subtle, EditorConfig _is_ a important step into producing high quality code. More often than not, more than one developer will work on a software, be it a NPM package or a Single Page App. Having EditorConfig in place, will minimize the chances of a developer messing with our code style and the encoding of our files.

### Modern JavaScript (ES6+)

JavaScript, as everybody knows, has gained mass adoption as the primary programming language over the last few years. Node.js, the responsible for this adoption, brought JavaScript to a horde of backend developers triggering a huge evolution on the language. These evolutions, although great, are not fully supported by every platform. [There are many JavaScript engines (and many different versions of these engines)](https://en.wikipedia.org/wiki/JavaScript_engine#Implementations) in the market ready to run code, but most of them do _not_ support the latest JavaScript features.

This rich environment created one big challenge for the community. How do we support different engines and their versions while using JavaScript most recent features? One possible answer to this question is Babel. [Babel, as stated by their official website, is a JavaScript compiler](https://babeljs.io/) that allows developers to use next generation JavaScript today.

> __Note__ that Babel is one alternative. There are others, like [TypeScript](https://www.typescriptlang.org/), for example.

Using Babel is straightforward. We just have to install this library as a development dependency and create a file called `.babelrc` to hold its configuration:

```bash
npm install --save-dev babel-cli babel-preset-env

echo '{
  "presets": ["env"]
}' >> .babelrc
```

With this file in place, we can configure a [NPM script](https://docs.npmjs.com/cli/run-script) to make Babel convert modern JavaScript in code supported by most environments. To do that, let's open the `./package.json` file and add to it a script called `build`:

```json
{
  ...
  "scripts": {
    "build": "babel ./src -d ./lib",
    ...
  }
  ...
}
```

When we run this new script, Babel takes the source code found in the `./src` directory (which can be written in modern JavaScript) and transforms it to ECMAScript 5 (the most supported version of JavaScript). To see this in action, let's create the aforementioned `./src` directory in the project root and add a script called `index.js` into it. To this script, let's add the following code:

```js
function sayHiTo(name) {
  return `Hi, ${name}`;
}

const message = sayHiTo('Bruno');

console.log(message);
```

Although short, this script contains code that is not supported by ECMAScript 5. For example, there is no `const` in this version, nor it accepts `Hi, ${name}` as a string. Trying to run this code into an old engine would result in error. Therefore, let's use Babel to compile it:

```bash
npm run build
```

After asking NPM to run the `build` script, we will be able to see that Babel created the `./lib` directory with `index.js` in it. This script, instead of our code above, contains the following:

```js
'use strict';

function sayHiTo(name) {
  return 'Hi, ' + name;
}

var message = sayHiTo('Bruno');

console.log(message);
```

Now we _do_ have a code that ECMAScript 5 engines can read and run. Now we can take advantage of the latest JavaScript features. So let's move on.

### ESLint

### Unit Tests

### Coding

### Test Coverage

### Publishing the NPM Package

### Continuous Integration

## Conclusion

As we can see, it's all about using the right tools, following the right processes, and applying best practices.
